# Isadora reviews

## 1

2: (accept)
The work concerns the creation (or "mining") of information flow properties directly from (RTL) hardware source code.

The flow presented takes a testbench and design, generates an instrumented design simulation, and from there derives "noninterference properties" and "declassification properties." The implementation is based on commercial EDA security tools and simulators, the Daikon invariant detector, and some python scripting. A sampling of the resulting (automatically generated) properties is (manually) mapped to CWE identifiers to assess their relevance. An analysis of sources of false positives and negatives in this approach is provided, together with practical details such as runtime.

The application of (daikon-style) dynamic invariant detection for analysis of hardware designs would seem to naturally complement formal property verification and has been explored in earlier works. Authors assert that this type of information flow analysis has not been published before, and the reviewer found the approach interesting and potentially useful for practical security work and verification engineering.

The reviewer noticed an undefined reference in Section 5.2 and some slightly clumsy language in places, but the paper appears generally well written and presented.

## 2

0: (borderline paper)
Summary: This paper introduces an automatic specification mining tool for information flow based security properties in RTL designs.

Strengths:
1. The paper is nicely written, and the concept is clear.
2. It is very nice that the proposed tool only needs to take the RTL design and a testbench for automatic specification and property mining. No additional manual inputs are needed.
3. The authors implemented their ideas and evaluated their scalability and effectiveness. The results are promising.

Weaknesses:
1. The proposed scheme is trace-based specification mining, and the traces are generated by the testbench provided together with the source code. However, there is only a limited amount of discussion (section 5.1) on how certain properties (e.g., completeness) of the testbench will affect the extracted properties out from it. I think this is an important aspect, and I expect to see a more in-depth analysis of this aspect. Also, it will be great if the authors can provide a set of rules or guidelines for designers to generate/check the testbench beforehand.
2. The grammar introduced in Section 2 is not explained clearly. More explanation on the formulas in Section 2 is needed. However, I feel I can still understand the rest of the paper without fully understanding the grammar, as it is not used extensively.

Editorial issues:
1. In Section 4.1, "though an AXI interconnect" -> "through an AXI interconnect".
2. In section 5.2, "from section ??"

# Astarte Reviews

## 1
2: (accept)
Mining LTL properties of hardware is an important problem, and I am glad to see progress in this direction. The paper provides nice examples. However, if possible, I'd like to see some details of the technical description of the approach. Also, although the goal is LTL properties, looks like the focus is primarily on invariants (i.e., properties of the form Gp). How do we extend this, for example for liveness properties, which are for example, critical for denial-of-service kinds of attacks?

## 2
3: (strong accept)
Security critical assertions are powerful assets for exposing security vulnerabilities but it takes a lot of expertise and manual efforts to compose. Assertion mining is a novel way to facilitate the development of security critical assertions. The proposed method is interesting and relevant. It will be good if experiments with artificially injected bugs can show the effectiveness of the generated assertions.

# Scheduling Reviews (This is basically a linear programming multiprocessor OS scheduler)

## 1

2: (accept)
This paper studies the problem of generating periodic schedule, called cyclic executive, for safety-critical systems on multicore platforms. It provides a set of results including formulating the problem for preemptive and non-preemptive scheduling in standard optimization framework, an approximation algorithm for the non-preemptive case, etc.


It will be nice to prove that the non-preemptive case is indeed NP-complete. This can better justify the use of ILP.

I am not convinced why Eqn(5) is necessary for a non-preemptive cyclic executive to exist. This is a critical step in justifying why the ILP formulation is generally applicable for the non-preemptive case. For example, consider two tasks on a single-core, \tau_1 = (0.1, 2), \tau_2 = (1.1, 3). Let f=F=1, hence the task set violates the condition in Eqn (5). But it seems to be possible to have a non-preemptive schedule. \tau_1 can execute in the intervals [0,0.1], [2, 2.1], [4.1,4.2]. \tau_2 can execute in the intervals [0.1,1.2], [3,4.1]. If so, I think the authors may make Eqn (5) an assumption.

The paper generally reads well. There are a few minor issues as below.

Abstract:
from the context, it should be "state-of-the-art ILP solvers"

Figure 1:
that can a single processor can -> that a single processor can

Example 2:
Corresponding to the solve job -> Corresponding to the sole job

Page 11:
It should be "E_2 compromises (n X (P/F)) edges"

It is better to say Constraint (4) instead of Constraint 4

## 2

1: (weak accept)
In this paper, the authors consider implementation of cyclic executives upon multi-core platforms. A Linear Programming (LP) based formulation is presented for a particular kind of recurrent real-time workload – collections of implicit-deadline periodic tasks. Techniques are described for solving the LP formulation under different kinds of restrictions in order to obtain preemptive and non-preemptive cyclic executives. The idea is attractive and the proof is detailed.


1 .Section 4.2 has two “§3” parts.

2. In Example 4, do the non-integer values assigned to the variables in jobs j2, j4 and j6 have an impact on the resulting bipartite graph?

3.In Section 6.3, it is concluded that polynomial-time approximation algorithms are applicable to the special case of harmonic task systems. How about other harmonic task systems? It is better to give the applicable scope of the presented algorithm.

4.In Figure 5, it seems that the speedup increases linear with systemwide utilization when utilization is larger than 2. When utilization is larger than 4, does the relationship still exist?

2: (accept)
This paper proposes a solution to (non-)preemtively schedule a periodic set of tasks to a multicore via (integer) linear programming.

As recognized by the authors, synthesis of schedules for multi-core architectures is one of the most important challenges for real-time systems. The paper, therefore, has a clear motivation. Apart from some typos, the paper is well-written.

Comments:

- Although its not wrong, I find the notation j_i for the i-th job a bit confusing, since j is also used as an index. For example, in paragraph 1 on page 7, j occurs in x_{ijk} and in j_i.

- In paragraph 2 on page 7 it is not clear that f is a new auxilary variable. I assume you work with identical processors? Otherwise, the definition of f is dependend on the processor. I find the explaination of the objective not very convincing. Essentially, f controls the speed of the processors. How is this related to makespan minimization?

- On page 7 above Example 1, you claim that the total number of variables is N*m*P/F. Here, you use that jobs are generated by the tasks. Please make it more explicit.

- You tend to use too many brackets: for example, N*(P/F) is just N*P/F, and outerbrackets are never necessery. This makes a clumsy impression. This occurs throughout the text in many places (I'm not going to list them :)).

- Paragraph 3 on page 9 is not necessary at this point. Your remark that no single jobs executes in parallel (concurrent execution of the same job is OK, as it is not simultaneous) on two different machines should move to after the McNaughton's wrap around.

- What is the motivation of Section 5.1? Is this network-flow approach part of the contribution of this paper? As far as I can tell, this approach is not used later on in the paper.

- You should mention on page 14 that it suffices the find a matching in the graph, as the constraints in Equation 3 and 4 are only about the quality of the solution.

Textual comments:

- p4 l-5: brackets in definition of J do not match.
- p4 l-3: Instead of just declaring jobs J to be generated from a set of periodic tasks, it is more clear if you explicitly mention that you assume that a_i = k*T_j, c_i = C_j and d_i=(k+1)*T_j, for some task tau_j and some integer k > 0.
- p5: Example 1 does not mention any worst-case execution times, although they are used later on in Example 3.
- p6: The second part of Fact 1 requires that the feasable region bounded too. Otherwise, an solution may not exist.
- p6: Fact 3 has a typo: v should be c. Otherwise, the fact is trivial :)
- p7 l12: "only execute" -> "execute only"
- p7 l13: "only takes" -> "takes"
- p7: the variables in Example 2 are have incorrect indices for the frames.
- p13: for clearity, write something like "constraints in Equation (2)" rather than "Constraints 2".
